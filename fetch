#!/usr/bin/env python3
# 2026-02-03T22:27:09+01:00 SHA-256:4767e6856d36febde73cd3c1dfbb457317c1486ed3a9324edc102791e8c15ee8

import argparse
import contextlib
import datetime
import hashlib
import json
import os
import random
import stat
import string
import sys
import urllib.request
from dataclasses import dataclass
from typing import Self, Tuple

import logging
logger = logging.getLogger(__name__)

whoami = "fetch"
env_prefix = f"{whoami.upper()}_"

def env(var, default=None):
    return os.environ.get(env_prefix + var, default)

def chmod_plus_x(path):
    umask = os.umask(0)
    os.umask(umask)
    os.chmod(path, os.stat(path).st_mode | ((stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH) & ~umask))

def fresh_salt(n=5):
    alphabeth = string.ascii_letters + string.digits
    return ''.join(random.choices(alphabeth, k=n))

def figure_out_version():
    with open(__file__, "rb") as this:
        ls = this.readlines()
        shebang = ls[0]
        assert shebang.startswith(b"#!")

        h = hashlib.sha256()
        for l in ls[1:]:
            h.update(l)
        return h.hexdigest()

def parse_args():
    parser = argparse.ArgumentParser(
            description = "One script to fetch them all and in git bind them",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("-v", "--version", action="version", version=figure_out_version())

    parser.add_argument("--log", default=env("LOG_LEVEL", "WARN"), help="set log level")

    default_root = env("ROOT", ".")
    default_manifest_filename = env("MANIFEST_FILENAME", f".{whoami}.json")
    parser.add_argument("--root", metavar="ROOT", default=default_root, help="act relative the directory ROOT")
    parser.add_argument("--manifest-filename", metavar="FILENAME", default=default_manifest_filename, help="load manifest from FILENAME (relative to the ROOT)")
    parser.add_argument("--manifest", metavar="PATH", default=env("MANIFEST"), help="load manifest from PATH")

    subparsers = parser.add_subparsers(dest="cmd")

    add_cmd = subparsers.add_parser("add")
    add_cmd.add_argument("--sha256", metavar="SHA256")
    add_cmd.add_argument("url", metavar="URL")
    add_cmd.add_argument("target", metavar="TARGET", nargs="?")

    verify_cmd = subparsers.add_parser("verify")
    verify_cmd.add_argument("target", metavar="TARGET", nargs="*")

    download_cmd = subparsers.add_parser("download")
    download_cmd.add_argument("-u", "--update", action="store_true", help="redownload and update the manifest")
    download_cmd.add_argument("target", metavar="TARGET", nargs="*")

    steal_this_script_cmd = subparsers.add_parser("steal-this-script")
    steal_this_script_cmd.add_argument("output", metavar="OUTPUT", nargs="?")

    return parser.parse_args()

def setup_logger(level):
    l = logging.getLogger("fetch")
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s", datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

def download(url, target=None):
    m = hashlib.sha256()
    if target is None:
        logger.info("fetching: %s", url)
    else:
        logger.info("fetching: %s -> %s", url, target.name)

    hdr = {
        "User-Agent": env("USER_AGENT", whoami),
    }
    req = urllib.request.Request(url, headers=hdr)
    with urllib.request.urlopen(req) as f:
        while True:
            bs = f.read(4096)
            if len(bs) == 0:
                break
            logger.debug("fetching; %s: %s bytes", url, len(bs))
            m.update(bs)
            if target:
                target.write(bs)
    sha256 = m.hexdigest()
    logger.info("fetched; %s: SHA256 %s", url, sha256)
    return sha256

def sha256_file(path):
    with open(path, "rb") as f:
        m = hashlib.sha256()
        while True:
            bs = f.read(4096)
            if len(bs) == 0:
                break
            m.update(bs)
    return m.hexdigest()

class Manifest:
    def __init__(self, path):
        self.path = path

        self._items = {}
        if os.path.exists(self.path):
            logger.debug("loading manifest: %s", self.path)
            with open(self.path, "r", encoding="UTF-8") as f:
                for i in map(lambda d: Item.from_dict(d, manifest=self), json.load(f)):
                    self._items[i.target] = i
        else:
            logger.debug("empty manifest intended for: %s", self.path)

    def __repr__(self):
        return f"Manifest({self.path})"

    def __contains__(self, item):
        if isinstance(item, Item):
            item = item.target
        return item in self._items

    def __getitem__(self, item):
        if isinstance(item, Item):
            item = item.target
        return self._items[item]

    def items(self):
        yield from self._items.values()

    def add(self, item):
        if item.target in self._items:
            raise NotImplementedError()
        self._items[item.target] = item

    def to_dict(self):
        items = sorted(self._items.values(), key=lambda i: i.target)
        items = map(lambda i: i.to_dict(), items)
        return list(items)

    def save(self):
        logger.debug("saving manifest: %s", self.path)
        with open(self.path, "w", encoding="UTF-8") as f:
            json.dump(self.to_dict(), f, sort_keys=True, indent=4)
            f.write("\n")

@dataclass
class ChecksumMismatch(Exception):
    a: Tuple[os.PathLike | str, str]
    b: Tuple[os.PathLike | str, str]
    alg: str = "SHA256"

    def __str__(self):
        return repr(self)

class Item:
    def __init__(self, url, target, manifest, sha256=None, timestamp=None): # pylint: disable=design
        self.url = url
        self.target = target
        self.manifest = manifest
        self.sha256 = sha256
        self.timestamp = timestamp
        self.local = None

    def __repr__(self):
        return f"Item({self.target}, {self.manifest})"

    def path(self, root=None):
        return os.path.join(root or os.getcwd(), self.target)

    def exists(self, root=None):
        return os.path.exists(self.path(root))

    def download(self, root=None, update=None) -> Self:
        path = self.path(root)
        self.timestamp = datetime.datetime.now().astimezone()
        os.makedirs(os.path.dirname(path), exist_ok=True)
        self.local = path

        tmp = path + f".{whoami}.{fresh_salt()}"
        try:
            with open(tmp, "xb") as f:
                fetched = download(self.url, f)

            if self.sha256 is not None and not update:
                if fetched != self.sha256:
                    raise ChecksumMismatch(a=(self.url, fetched), b=(f"{self}.sha256", self.sha256))

                if os.path.exists(path):
                    local = sha256_file(path)
                    if local != self.sha256:
                        raise ChecksumMismatch(a=(path, local), b=(f"{self}.sha256", self.sha256))

            self.sha256 = fetched
            os.rename(tmp, path)
        finally:
            if os.path.exists(tmp):
                os.remove(tmp)

        return self

    def verify(self, root=None, url=None, sha256=None):
        if url is not None and self.url != url:
            raise RuntimeError("url doesn't match manifest", url, self.url)

        if sha256 is not None and self.sha256 != sha256:
            raise RuntimeError("sha256 doesn't match manifest", sha256, self.sha256)

        path = self.path(root)
        logger.debug("verifying: %s", path)
        local = sha256_file(path)
        if local != self.sha256:
            raise ChecksumMismatch(a=(path, local), b=(f"{self}.sha256", self.sha256))
        self.local = path
        return self

    def to_dict(self):
        assert self.timestamp is not None
        d = {
            "target": self.target,
            "url": self.url,
            "sha256": self.sha256,
            "timestamp": self.timestamp.isoformat(timespec="seconds"),
        }

        return d

    @staticmethod
    def from_dict(d, manifest=None):
        return Item(
            target = d["target"],
            url = d["url"],
            sha256 = d["sha256"],
            timestamp = datetime.datetime.fromisoformat(d["timestamp"]),
            manifest = manifest,
        )

def resolve_root_and_manifest(args):
    root = args.root
    if root == ".":
        root = os.getcwd()
    logger.debug("root: %s", root)

    manifest_path = args.manifest
    if args.manifest is None:
        manifest_path = os.path.join(root, args.manifest_filename)

    manifest = Manifest(manifest_path)
    return root, manifest

def do_add(args):
    root, manifest = resolve_root_and_manifest(args)

    target = args.target
    if target is None:
        target = os.path.basename(args.url)

    target = os.path.relpath(os.path.join(root, target), start=root)

    if target in manifest:
        item = manifest[target]
        if not item.exists(root=root):
            item = item.download(root=root)
        item = item.verify(url=args.url, sha256=args.sha256, root=root)
    else:
        item = Item(url=args.url, sha256=args.sha256, target=target, manifest=manifest)
        item.download(root=root)
        manifest.add(item)

    assert item.local is not None
    print(os.path.relpath(item.local, start=root))

    manifest.save()

def do_download(args):
    root, manifest = resolve_root_and_manifest(args)

    items = set()
    if vars(args).get("target"):
        for i in manifest.items():
            if i.target in args.target:
                items.add(i)
    else:
        items = manifest.items()

    for i in items:
        i.download(root=root, update=args.update)
        print(os.path.relpath(i.local, start=root))

    manifest.save()

def do_verify(args):
    root, manifest = resolve_root_and_manifest(args)

    items = set()
    if vars(args).get("target"):
        for i in manifest.items():
            if i.target in args.target:
                items.add(i)
    else:
        items = manifest.items()

    for i in items:
        i.verify(root=root)
        print(os.path.relpath(i.local, start=root))

def do_steal_this_script(args):
    if args.output is None:
        dst = contextlib.nullcontext(sys.stdout.buffer)
    else:
        dst = open(args.output, "wb")

    with open(__file__, "rb") as src, dst as dst:
        ls = src.readlines()
        shebang = ls[0]
        assert shebang.startswith(b"#!")
        dst.write(shebang)

        h = hashlib.sha256()
        for l in ls[1:]:
            h.update(l)
        sha256 = h.hexdigest()

        now = datetime.datetime.now().astimezone().isoformat(timespec="seconds")
        dst.write(f"# {now} SHA-256:{sha256}\n".encode("UTF-8"))

        for l in ls[1:]:
            dst.write(l)

    if args.output is not None:
        chmod_plus_x(args.output)

def main():
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug("args: %s", args)

    if args.cmd == "add":
        do_add(args)
    elif args.cmd is None or args.cmd == "verify":
        do_verify(args)
    elif args.cmd == "download":
        do_download(args)
    elif args.cmd == "steal-this-script":
        do_steal_this_script(args)
    else:
        raise RuntimeError(f"unexpected command: {args.cmd}")

if __name__ == "__main__":
    main()
